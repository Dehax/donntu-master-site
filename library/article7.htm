<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Система обеспечения устойчивости программ к несанкционированной модификации — К. Попырко</title>
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
  <link rel="stylesheet" type="text/css" href="../css/style.css">
</head>

<body>
  <div class="NavbarTopOffset"></div>

  <div class="container">
    <nav class="navbar navbar-expand-xl navbar-dark bg-primary fixed-top" id="menu">
      <a class="navbar-brand" href="/" target="_blank" title="Перейти на портал магистров ДонНТУ">Портал магистров</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Переключить меню">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav mx-auto">
          <li class="nav-item">
            <a class="nav-link" href="../index.htm">Резюме</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../bio/index.htm">Биография</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../diss/index.htm">Реферат</a>
          </li>
          <li class="nav-item">
            <a class="nav-link active" href="../library/index.htm">Библиотека</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../links/index.htm">Ссылки</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../links/zvit.htm">Отчёт о поиске</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../ind/index.htm">Индивидуальный раздел</a>
          </li>
        </ul>
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link" href="http://donntu.org" target="_blank" title="Перейти на сайт ДонНТУ">ДонНТУ</a>
          </li>
        </ul>
      </div>
    </nav>

    <main class="card shadow my-4" id="middleblock">
      <div class="card-body">
        <div id="maintext">
          <h1 class="text-center">Система обеспечения устойчивости программ к несанкционированной модификации</h1>

          <p>
            <strong>Автор:</strong> К. Попырко<br>
            <strong>Источник:</strong> <a href="/2013/fknt/popyrko/ref.html">Портал магистров ДонНТУ, Попырко Кирилл, Реферат</a>
          </p>

          <h2>Актуальность темы</h2>

          <p>
            Проблема защиты программного обеспечения (ПО) от несанкционированной модификации остается актуальной для
            большинства программистов, которые занимаются разработкой платного программного обеспечения. Хорошо
            защищенная программа гораздо дольше остается не взломанной, что способствует получению максимальной прибыли
            от её продаж. Сравнительный график получения прибыли от продаж плохо защищенного и хорошо защищенного
            продуктов представлен на рисунке 1.
          </p>

          <div class="text-center">
            <figure class="figure">
              <img class="figure-img" src="article7/fig1.png" alt="Графики получения прибыли от продаж плохо защищенного и хорошо защищенного продуктов">
              <figcaption class="figure-caption">Рисунок 1 – Графики получения прибыли от продаж плохо защищенного и хорошо защищенного продуктов</figcaption>
            </figure>
          </div>

          <h2>Введение</h2>

          <p>
            Взлом защиты программного обеспечения невозможен без изучения защитных механизмов, используемых в этом ПО.
            Изучение программного продукта может осуществляться методом статического и/или динамического анализа. При
            статическом анализе разработка алгоритма взлома защиты производится на основе анализа результатов
            дизассемблирования или декомпиляции исследуемой программы. Для динамического анализа взламываемую программу
            запускают в среде отладчика, при этом становится возможным контроль всех изменений, возникающих в процессе
            функционирования приложения. В процессе динамического анализа, используя режим отладки, производят пошаговое
            прохождение «защитных» алгоритмов программы, например алгоритмов проверки или генерации корректного
            регистрационного кода.
          </p>

          <p>
            Схема получения исходного кода на языке ассемблера для программного обеспечения представлена на рисунке 1.
          </p>

          <div class="text-center">
            <figure class="figure">
              <img class="figure-img" src="article7/fig2.gif" alt="Схема получения исходного кода на языке ассемблера для программного обеспечения">
              <figcaption class="figure-caption">Рисунок 2 – Схема получения исходного кода на языке ассемблера для программного обеспечения</figcaption>
            </figure>
          </div>

          <p>
            Имея доступ к исходному коду, исследователь может изменить исполняемый файл таким образом, чтобы изменить
            поведение программного обеспечения на поведение, соответствующее зарегистрированной версии программы. Исходя
            из вышеизложенного, можно сказать, что для защиты программного обеспечения от несанкционированного
            исследования и/или модификации, необходимо максимально усложнить статический и динамический анализ.
          </p>

          <h2>Исследование существующих методов защиты ПО</h2>

          <p>
            Среди наиболее часто применяемых методов защиты ПО можно выделить следующие:
          </p>

          <h3>1. Упаковка и/или шифрование исходного файла</h3>

          <p>
            Защищаемый файл полностью или частично упаковывается и/или шифруется криптографическим алгоритмом.
            Распаковка и/или расшифровка, а также передача управления на оригинальный код происходит в памяти, что
            делает невозможным проведение статического анализа. Однако, в процессе динамического анализа такая защита
            может быть полностью снята исследователем, т.е. после распаковки и/или расшифровки исходный файл находится в
            памяти компьютера в «чистом» виде. Т. о., после снятия дампа с области памяти, в которой находится исходный
            файл, можно продолжить анализ.
          </p>

          <h3>2. Запутывание (обфускация) кода</h3>

          <p>
            Эффективность данного метода достигается за счет использования особенностей человеческого фактора — чем
            сложнее исходный код и чем больше ресурсов использует приложение, тем сложнее исследователю понять логику
            работы программы, а, следовательно, и взломать примененные средства защиты. Обфускация (запутывание) кода
            может быть произведена различными способами, при этом наибольший эффект защиты достигается при
            комбинировании их друг с другом. Ниже представлены основные методы обфускации.
          </p>

          <h4>2.1. Вставка мусорного кода</h4>

          <p>
            В код программы осуществляется вставка случайного числа инструкций, которые не изменяют поведение программы,
            но при этом вносят неясность в код, увеличивая тем самым количество необходимого времени, требуемого
            исследователю на изучение алгоритма. Пример данного метода обфускации приведен на рисунке 3.
          </p>

          <div class="text-center">
            <figure class="figure">
              <img class="figure-img" src="article7/fig3.png" alt="Вставка мусорного кода">
              <figcaption class="figure-caption">Рисунок 3 – Вставка мусорного кода</figcaption>
            </figure>
          </div>

          <h4>2.2. Изменение потока выполнения</h4>

          <p>
            В код программы осуществляется вставка случайных условных и/или безусловных переходов в код, которые
            запутывают код, и, соответственно, затрудняют понимание алгоритма исследователем. Пример данного метода
            обфускации приведен на рисунке 4.
          </p>

          <div class="text-center">
            <figure class="figure">
              <img class="figure-img" src="article7/fig4.png" alt="Изменение потока выполнения">
              <figcaption class="figure-caption">Рисунок 4 – Изменение потока выполнения</figcaption>
            </figure>
          </div>

          <h4>2.3. Мутация кода</h4>

          <p>
            Существующие инструкции в коде одно- или многократно преобразовываются в другие, аналогичные по
            функциональности. Пример данного метода обфускации приведен на рисунке 5.
          </p>

          <div class="text-center">
            <figure class="figure">
              <img class="figure-img" src="article7/fig5.png" alt="Мутация кода">
              <figcaption class="figure-caption">Рисунок 5 – Мутация кода</figcaption>
            </figure>
          </div>

          <h4>2.4. Виртуализация кода</h4>

          <p>
            Инструкции кода защищаемого приложения преобразуются в инструкции абстрактной виртуальной машины с
            неизвестной системой команд, архитектурой и логикой работы. Виртуализованные участки кода выполняются
            интерпретатором без предварительного преобразования в инструкции процессора. Является одним из наиболее
            эффективных методов затруднения анализа кода исполняемых файлов, т. к. для внесения изменения в защитные
            алгоритмы ПО с целью взлома, исследователю необходимо полностью изучить архитектуру виртуальной машины,
            создать дизассемблер, соответствующий этой архитектуре, и проанализировать полученный дизассемблерный код.
          </p>

          <h3>3. Скрытие вызовов API-функций</h3>

          <p>
            Позволяет скрыть от исследователя список API, которые использует защищаемая программа. Основные способы
            скрытия API-вызовов:
            <ul>
              <li>Скрываемые функции отсутствуют в таблице импорта, адреса этих функций определяются динамически уже во время работы защищенного файла, а не на этапе работы стандартного загрузчика Windows.</li>
              <li>Эмуляция некоторых API-функций  перенаправление прямого вызова API-функции на вызов внутренней функции, которая полностью повторяет поведение скрываемой функции.</li>
            </ul>
          </p>

          <h3>4. Применение анти-отладочных методов</h3>

          <p>
            Способ заключается в определении, запущена ли программа в среде отладчика  если да, выполнение программы
            завершается. Наиболее распространенные методы:
            <ul>
              <li>Использование API-функций (IsDebuggerPresent, CheckRemoteDebuggerPresent);</li>
              <li>Поиск отладчика в системе (по имени процесса, по имени/классу окна отладчика, по создаваемым объектам ядра).</li>
            </ul>
          </p>

          <h3>5. Применение анти-дамп методов</h3>

          <p>
            Способ заключается в применении технологий, затрудняющих получение дампа процесса после
            распаковки/расшифровки. Наиболее распространенные методы приведены ниже.
          </p>

          <p>
            Затирание заголовка исполняемого файла в оперативной памяти — в результате чего образ, полученный после
            дампа, невозможно будет запустить.
          </p>

          <p>
            «Краденые байты (stolen bytes)» — технология заключается в «краже» случайных команд из кода и перемещении их
            в динамически выделяемую память. Т. к. память, выделенная в процессе исполнения, не принадлежит образу
            исполняемого файла, то адреса безусловных переходов в дампе будут ссылаться на несуществующие адреса. Т. о.,
            для восстановления работоспособности, исследователю необходимо будет найти все такие места и полностью
            восстановить весь «украденный» код.
          </p>

          <div class="text-center">
            <figure class="figure">
              <img class="figure-img" src="article7/fig6.png" alt="«Краденые байты (stolen bytes)»">
              <figcaption class="figure-caption">Рисунок 6 – «Краденые байты (stolen bytes)»</figcaption>
            </figure>
          </div>

          <h3>6. Скрытие строк</h3>

          <p>
            Применяется для скрытия строк, которые неявно могут указывать на функции проверки/генерации серийных номеров
            и т.п.. На рисунках 7 и 8 приведен пример приложения, в секции данных которого находятся строки, которые
            однозначно указывают на функцию проверки серийного номера.
          </p>

          <div class="text-center">
            <figure class="figure">
              <img class="figure-img" src="article7/fig7.png" alt="Содержимое секции данных исследуемого приложения">
              <figcaption class="figure-caption">Рисунок 7 – Содержимое секции данных исследуемого приложения</figcaption>
            </figure>
          </div>

          <div class="text-center">
            <figure class="figure">
              <img class="figure-img" src="article7/fig8.png" alt="Функция проверки серийного номера исследуемого приложения в отладчике">
              <figcaption class="figure-caption">Рисунок 8 – Функция проверки серийного номера исследуемого приложения в отладчике</figcaption>
            </figure>
          </div>

          <h2>Обзор существующих решений защиты программ от взлома</h2>

          <p>
            Основным инструментом, применяемым для защиты приложений от взлома, являются программы-протекторы. Описания
            и характеристики наиболее популярных из них приведены ниже.
          </p>

          <h3>1. VmProtect</h3>

          <p>
            VMProtect — средство защиты программного обеспечения. Поддерживаемые форматы файлов: EXE, DLL;
            поддерживаемые операционные системы: все 32/64-разрядные операционные системы семейства Windows.
            Используемые методы защиты в VmProtect приведены ниже:
            <ol>
              <li>
                Обфускация кода в VMProtect: виртуализация, мутация и смешанный метод защиты, сочетающий мутацию кода
                приложения с его последующей виртуализацией. При виртуализации участков кода, VMProtect позволяет
                использовать несколько отличных друг от друга виртуальных машин для защиты разных участков кода одного
                приложения, что еще больше усложняет процесс взлома защиты, так как взломщику будет необходимо
                анализировать архитектуру уже нескольких виртуальных машин. В процессе мутации, помимо замены команд их
                функциональными аналогами, в код приложения добавляются «мусорные» команды, и случайные условные и
                безусловные переходы.
              </li>
              <li>
                Применение анти-отладочных приемов для защиты от динамического анализа  в VMProtect применяются
                различные методы обнаружения отладчика.
              </li>
              <li>
                Скрытие вызовов API-функций.
              </li>
            </ol>
          </p>

          <h3>2. The Enigma Protector</h3>

          <p>
            The Enigma Protector — система защиты исполняемых файлов. Содержит широкий ряд уникальных функций и
            возможностей, основной целью которых является защита исполняемых файлов от нелегального копирования, взлома,
            модификации и исследования. Поддерживаемые форматы файлов: x86/x64 EXE/DLL файлы для любых версий семейства
            ОС Windows. Используемые методы защиты представлены ниже:
            <ol>
              <li>Обфускация кода выполняется виртуализацией заданных участков кода.</li>
              <li>Применение различных анти-отладочных приемов</li>
              <li>Скрытие вызовов API-функций.</li>
            </ol>
          </p>

          <h3>3. Themida</h3>

          <p>
              Themida — система защиты исполняемых файлов. Поддерживаемые форматы файлов: x86/x64 EXE и DLL исполняемые файлы семейства операционных систем Windows. Для защиты используется технология «SecureEngine», которая использует следующие техники защиты:
              <ol>
                <li>Для обфускации кода, применяются следующие техники: SmartMetamorph и MutatorEngine (мутация кода), GarbageCode (вставка мусорного кода), VirtualMachine (виртуализация кода).</li>
                <li>Шифрование части исполняемого файла: техника CodeEncrypt (зашифрованные блоки кода расшифровываются только при обращении к ним).</li>
                <li>Применение анти-отладочных приемов  MemoryGuard (защита памяти приложения от изменения в момент выполнения), DebuggerGuard (техника обнаружения отладчиков в системе), AntiBreakpoints (техника, затрудняющая установку точек останова при запуске приложения в среде отладчика), AntiDumperPro (техники, затрудняющие получение «дампа» процесса защищенного приложения).</li>
                <li>Скрытие вызовов API-функций  SecureAPIWrapper (скрытие таблицы импорта).</li>
              </ol>
          </p>

          <h3>4. Obsidium</h3>

          <p>
            Obsidium — система защиты программного обеспечения от несанкционированного исследования и модификации.
            Поддерживаемые форматы файлов: x86/x64 EXE и DLL исполняемые файлы семейства ОС Windows. Используемые методы
            защиты:
            <ol>
              <li>Для обфускации кода применяются упаковка, шифрование и виртуализация кода.</li>
              <li>Применение анти-отладочных приемов.</li>
              <li>Скрытие API-функций.</li>
            </ol>
          </p>

          <h2>Сравнение рассмотренных продуктов</h2>

          <p>
            На рисунках 9, 10, 11 приведены сравнительные диаграммы количественных параметров рассмотренных протекторов,
            полученные при защите тестового приложения
          </p>

          <p>
            Тестовое приложение представляет собой простейший аналог коммерческого приложения с защитой от
            несанкционированного копирования с помощью лицензионного ключа. Алгоритм программы не линеен, т. к.
            существует условие проверки лицензионного ключа — в случае, если значение лицензионного ключа совпадает с
            заданным в программе, на экран выводится сообщение «OK! Program registered!», иначе  «Error! Invalid serial
            number!». Для чтения из файла используются стандартные функции runtime-библиотеки C++ «fopen», «fread» и
            «fclose». Для преобразования текстового представления лицензионного ключа в численное, используется функция
            той же библиотеки «atol».
          </p>

          <p>
            Параметры защиты, установленные в каждом из рассматриваемых протекторов:
            <ul>
              <li>Обфускация кода: виртуализация одной выбранной функции</li>
              <li>Скрытие вызовов API-функций</li>
              <li>Анти-отладочные приемы: обнаружение отладчиков</li>
            </ul>
          </p>

          <p>
            Все остальные параметры каждого из протектора были оставлены в их значении «по умолчанию». Исходные значения
            сравниваемых количественных параметров:
            <ul>
              <li>размер исходного файла: 2 (кБ);</li>
              <li>объем оперативной памяти, занимаемой программой: 2076 (кБ);</li>
              <li>время выполнения программы: 0.01 (сек).</li>
            </ul>
          </p>

          <p>
            Сравнительная характеристика описанных протекторов по параметру «размер файла» после обработки протектором
            приведена на рисунке 9.
          </p>

          <div class="text-center">
            <figure class="figure">
              <img class="figure-img" src="article7/fig9.png" alt="Сравнительная характеристика описанных протекторов по параметру «размер файла»">
              <figcaption class="figure-caption">Рисунок 9 – Сравнительная характеристика описанных протекторов по параметру «размер файла»</figcaption>
            </figure>
          </div>

          <p>
            Сравнительная характеристика описанных протекторов по параметру «время выполнения программы» после обработки
            протектором приведена на рисунке 10.
          </p>

          <div class="text-center">
            <figure class="figure">
              <img class="figure-img" src="article7/fig10.png" alt="Сравнительная характеристика описанных протекторов по параметру «время выполнения программы»">
              <figcaption class="figure-caption">Рисунок 10 – Сравнительная характеристика описанных протекторов по параметру «время выполнения программы»</figcaption>
            </figure>
          </div>

          <p>
            Сравнительная характеристика описанных протекторов по параметру «объем занимаемой оперативной памяти» после
            обработки протектором приведена на рисунке 11.
          </p>

          <div class="text-center">
            <figure class="figure">
              <img class="figure-img" src="article7/fig11.png" alt="Сравнительная характеристика описанных протекторов по параметру «объем занимаемой оперативной памяти»">
              <figcaption class="figure-caption">Рисунок 11 – Сравнительная характеристика описанных протекторов по параметру «объем занимаемой оперативной памяти»</figcaption>
            </figure>
          </div>

          <p>
            Исходя из вышеизложенного, можно сказать что защита, добавленная протектором Enigma, более «сложная», т. к.
            защищенный файл имеет максимальный размер, что означает большее количество добавленного кода, который
            необходимо будет проанализировать исследователю. Также, на выполнение кода ушло максимальное количество
            времени. Однако, при более глубоком анализе защищенного приложения в отладчике, было выяснено, что
            значительное увеличение времени выполнения достигается благодаря добавлению большого количества бесполезных
            циклов. Т. о., необходимо отметить, что данный пункт не может рассматриваться как пункт, однозначно
            оценивающий степень защищенности приложения. Также, нужно отметить, что выбранные количественные параметры,
            по которым сравнивались рассматриваемые протекторы, не позволяют в полной мере оценить сложность взлома
            программы, защищенной соответствующим протектором, т.к. важнейшим фактором является уровень квалификации
            исследователя.
          </p>

          <h2>Выводы</h2>

          <p>
            Магистерская работа посвящена актуальной научной задаче защиты программного обеспечения от
            несанкционированной модификации. В рамках проведенных исследований выполнено:
            <ul>
              <li>Исследование существующих методов защиты ПО;</li>
              <li>Реализация методов защиты «упаковка» и «шифрование».</li>
            </ul>
          </p>

          <p>
            Дальнейшая работа направлена на следующие аспекты:
            <ul>
              <li>Реализация методов защиты «обфускация».</li>
            </ul>
          </p>

          <h2>Список источников</h2>

          <ol>
            <li id="ref1">Michael Sikorski and Andrew Honig: PRACTICAL MALWARE ANALYSIS The Hands-On Guide to Dissecting Malicious Software. – No Starch Press, Inc., 2012. – 802 с.</li>
            <li id="ref2">Chris Eagle: THE IDA PRO BOOK 2ND EDITION The Unofficial Guide to the World’s Most Popular Disassembler. – No Starch Press, Inc., 2011. – 676 с.</li>
            <li id="ref3">Randall Hyde: ART OF ASSEMBLY LANGUAGE, 2ND EDITION. – No Starch Press, Inc., 2010. – 760 с.</li>
            <li id="ref4">Г. Хогланд, Гари МакГроу: Взлом программ: анализ и примеры. – Вильямс, 2005. – 400 с.</li>
            <li id="ref5">Александр Панов: Реверсинг и защита программ от взлома. – БХВ-Петербург, 2006. – 256 с.</li>
            <li id="ref6">Крис Касперски, Ева Рокко: Искусство дизассемблирования. – БХВ-Петербург, 2004. – 896 с.</li>
            <li id="ref7">Крис Касперски: Образ мышления - дизассемблер IDA. – СОЛОН - Р, 2002. – 480 с.</li>
          </ol>
        </div>
      </div>
    </main>
  </div>

  <!-- Optional JavaScript -->
  <!-- jQuery first, then Popper.js, then Bootstrap JS -->
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
</body>
</html>
